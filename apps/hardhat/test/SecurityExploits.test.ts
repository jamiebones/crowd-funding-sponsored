import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";

describe("ðŸ” Platform Design Features & Actual Vulnerabilities", () => {
    async function deployFixture() {
        const [deployer, factoryOwner, campaignOwner, attacker, donor1, donor2, donor3] = await ethers.getSigners();

        // Deploy token
        const TokenFactory = await ethers.getContractFactory("CrowdFundingToken");
        const token = await TokenFactory.deploy();
        await token.waitForDeployment();

        // Deploy implementation
        const ImplementationFactory = await ethers.getContractFactory("CrowdFunding");
        const implementation = await ImplementationFactory.deploy();
        await implementation.waitForDeployment();

        // Deploy factory
        const FactoryFactory = await ethers.getContractFactory("CrowdFundingFactory");
        const factory = await FactoryFactory.deploy(
            await implementation.getAddress(),
            await token.getAddress()
        );
        await factory.waitForDeployment();

        // Setup token
        await token.setFactoryAndTransferOwnership(await factory.getAddress());

        return {
            factory,
            token,
            implementation,
            deployer,
            factoryOwner: deployer, // deployer is factory owner
            campaignOwner,
            attacker,
            donor1,
            donor2,
            donor3,
        };
    }

    async function createCampaign(factory: any, owner: any, goal = "10", duration = 90) {
        const fee = await factory.getFundingFee();
        const tx = await factory.connect(owner).createNewCrowdFundingContract(
            "QmTestCID",
            0, // TECHNOLOGY
            "Test Campaign",
            ethers.parseEther(goal),
            duration * 24 * 60 * 60,
            { value: fee }
        );
        await tx.wait();

        const campaigns = await factory.getDeployedCrowdFundingContracts();
        return await ethers.getContractAt("CrowdFunding", campaigns[campaigns.length - 1]);
    }

    describe("ðŸŸ¦ DESIGN FEATURE: Dynamic Donation Scale System", () => {
        it("Should demonstrate how donation scale affects token distribution", async () => {
            const { factory, token, campaignOwner, attacker, donor1 } = await loadFixture(deployFixture);

            console.log("\n=== DESIGN FEATURE: Donation Scale System ===");
            console.log("Purpose: Incentivize donations through promotional periods\n");

            const campaign = await createCampaign(factory, campaignOwner);

            // Phase 1: Normal users donate at 1x scale
            console.log("\nðŸ“Š Phase 1: Early donors at 1x scale");
            await campaign.connect(donor1).giveDonationToCause({ value: ethers.parseEther("10") });

            const donor1Tokens = await token.balanceOf(donor1.address);
            console.log("  Donor1: 10 ETH â†’ ", ethers.formatEther(donor1Tokens), "tokens");
            console.log("  Scale: 1x");

            // Phase 2: Attacker (as factory owner) changes scale to 10,000x
            console.log("\nâš ï¸  Phase 2: Attacker changes scale to 10,000x");
            await factory.setDonationScale(10000);
            console.log("  New scale: 10,000x");

            // Phase 3: Attacker donates small amount but gets massive tokens
            console.log("\nðŸ’° Phase 3: Attacker donates at 10,000x scale");
            await campaign.connect(attacker).giveDonationToCause({ value: ethers.parseEther("1") });

            const attackerTokens = await token.balanceOf(attacker.address);
            console.log("  Attacker: 1 ETH â†’ ", ethers.formatEther(attackerTokens), "tokens");

            // Calculate voting power
            const totalTokens = donor1Tokens + attackerTokens;
            const attackerVotingPower = (Number(attackerTokens) / Number(totalTokens)) * 100;
            const donor1VotingPower = (Number(donor1Tokens) / Number(totalTokens)) * 100;

            console.log("\nðŸ“ˆ Voting Power Distribution:");
            console.log("  Donor1 (10 ETH): ", donor1VotingPower.toFixed(2), "%");
            console.log("  Attacker (1 ETH): ", attackerVotingPower.toFixed(2), "%");

            console.log("\nðŸš¨ EXPLOIT SUCCESSFUL:");
            console.log("  Attacker spent 10x less money but has", attackerVotingPower.toFixed(0) + "x more voting power!");
            console.log("  Attacker controls", attackerVotingPower.toFixed(2) + "% of votes with only 9% of ETH invested");

            // Verify the exploit
            expect(attackerTokens).to.be.gt(donor1Tokens);
            expect(attackerVotingPower).to.be.gt(90); // Attacker has >90% voting power
        });

        it("Should demonstrate economic attack via scale manipulation", async () => {
            const { factory, token, campaignOwner, attacker, donor1, donor2 } = await loadFixture(deployFixture);

            console.log("\n=== EXPLOIT: Economic Manipulation ===");

            const campaign = await createCampaign(factory, campaignOwner);

            // Phase 1: Many users donate at 1x scale
            console.log("\nðŸ“Š Phase 1: Users donate at 1x scale");
            await campaign.connect(donor1).giveDonationToCause({ value: ethers.parseEther("5") });
            await campaign.connect(donor2).giveDonationToCause({ value: ethers.parseEther("5") });

            const totalDonated = ethers.parseEther("10");
            console.log("  Total donated: 10 ETH by 2 donors");
            console.log("  Total tokens minted: 10 tokens (1x scale)");

            // Phase 2: Attacker boosts scale massively
            console.log("\nâš ï¸  Phase 2: Attacker (factory owner) changes scale");
            await factory.setDonationScale(5000);

            // Phase 3: Attacker makes small donation
            console.log("\nðŸ’£ Phase 3: Attacker exploits high scale");
            await campaign.connect(attacker).giveDonationToCause({ value: ethers.parseEther("2") });

            const donor1Tokens = await token.balanceOf(donor1.address);
            const donor2Tokens = await token.balanceOf(donor2.address);
            const attackerTokens = await token.balanceOf(attacker.address);

            console.log("\nðŸ“ˆ Token Distribution:");
            console.log("  Donor1 (5 ETH): ", ethers.formatEther(donor1Tokens), "tokens");
            console.log("  Donor2 (5 ETH): ", ethers.formatEther(donor2Tokens), "tokens");
            console.log("  Attacker (2 ETH): ", ethers.formatEther(attackerTokens), "tokens");

            const totalSupply = donor1Tokens + donor2Tokens + attackerTokens;
            const attackerPercentage = (Number(attackerTokens) / Number(totalSupply)) * 100;

            console.log("\nðŸš¨ EXPLOIT RESULT:");
            console.log("  Attacker invested 16.7% of total ETH (2/12)");
            console.log("  But controls", attackerPercentage.toFixed(2) + "% of all tokens!");
            console.log("  Token dilution factor:", (Number(attackerTokens) / Number(donor1Tokens)).toFixed(0) + "x");

            expect(attackerPercentage).to.be.gt(80); // Attacker has >80% of tokens
        });
    });

    describe("ðŸ”´ HIGH: First Milestone Auto-Approval Bypass", () => {
        it("Should demonstrate instant withdrawal without community approval", async () => {
            const { factory, campaignOwner, donor1, donor2, donor3 } = await loadFixture(deployFixture);

            console.log("\n=== EXPLOIT: First Milestone Auto-Approval ===");

            // Create campaign with 1 day duration for quick exit
            console.log("\nðŸ“ Phase 1: Create campaign with 1 day duration");
            const campaign = await createCampaign(factory, campaignOwner, "10", 1);

            // Donors contribute
            console.log("\nðŸ’° Phase 2: Donors contribute funds");
            await campaign.connect(donor1).giveDonationToCause({ value: ethers.parseEther("30") });
            await campaign.connect(donor2).giveDonationToCause({ value: ethers.parseEther("40") });
            await campaign.connect(donor3).giveDonationToCause({ value: ethers.parseEther("30") });

            const totalRaised = ethers.parseEther("100");
            console.log("  Total raised: 100 ETH");

            // Fast forward 1 day
            console.log("\nâ° Phase 3: Wait 1 day for campaign to end");
            await time.increase(1 * 24 * 60 * 60 + 1);

            // End campaign
            await campaign.connect(campaignOwner).endCampaign();
            console.log("  Campaign ended");

            // Create first milestone
            console.log("\nðŸ“‹ Phase 4: Owner creates first milestone");
            await campaign.connect(campaignOwner).createNewMilestone("QmFirstMilestone");
            console.log("  Milestone created");

            // Withdraw immediately - NO VOTING REQUIRED!
            console.log("\nðŸš¨ Phase 5: Owner withdraws WITHOUT ANY VOTES");
            const ownerBalanceBefore = await ethers.provider.getBalance(campaignOwner.address);

            await campaign.connect(campaignOwner).withdrawMilestone();

            const ownerBalanceAfter = await ethers.provider.getBalance(campaignOwner.address);
            const withdrawn = ownerBalanceAfter - ownerBalanceBefore;

            console.log("  Owner withdrew:", ethers.formatEther(withdrawn), "ETH");
            console.log("  Percentage withdrawn: 33%");
            console.log("  Community votes required: ZERO âŒ");

            const contractBalance = await campaign.contractBalance();
            console.log("\nðŸ“Š Result:");
            console.log("  Remaining in contract:", ethers.formatEther(contractBalance), "ETH");
            console.log("  Owner got 33 ETH with NO community oversight!");

            console.log("\nðŸš¨ EXPLOIT SUCCESSFUL:");
            console.log("  âœ“ Campaign ended after 1 day");
            console.log("  âœ“ First milestone auto-approved");
            console.log("  âœ“ 33% of funds withdrawn without voting");
            console.log("  âœ“ Donors had NO say in the matter");

            // Verify exploit
            expect(withdrawn).to.be.gt(ethers.parseEther("32")); // ~33 ETH minus gas
            expect(contractBalance).to.be.lt(ethers.parseEther("68"));
        });

        it("Should demonstrate complete fund extraction via auto-approval", async () => {
            const { factory, campaignOwner, donor1 } = await loadFixture(deployFixture);

            console.log("\n=== EXPLOIT: Complete Fund Extraction ===");

            const campaign = await createCampaign(factory, campaignOwner, "5", 1);

            // Single donor
            await campaign.connect(donor1).giveDonationToCause({ value: ethers.parseEther("10") });
            console.log("\nðŸ’° Donor contributed: 10 ETH");

            // End campaign
            await time.increase(1 * 24 * 60 * 60 + 1);
            await campaign.endCampaign();

            // Milestone 1: Auto-approved (33%)
            console.log("\nðŸ“‹ Milestone 1: Creating...");
            await campaign.connect(campaignOwner).createNewMilestone("QmM1");
            await campaign.connect(campaignOwner).withdrawMilestone();
            console.log("  âœ“ Withdrawn ~3.33 ETH (AUTO-APPROVED, no votes needed)");

            // Milestone 2: No votes (auto-approved after timeout)
            console.log("\nðŸ“‹ Milestone 2: Creating...");
            await campaign.connect(campaignOwner).createNewMilestone("QmM2");
            await time.increase(15 * 24 * 60 * 60); // Wait voting period
            await campaign.connect(campaignOwner).withdrawMilestone();
            console.log("  âœ“ Withdrawn ~4.44 ETH (no votes = auto-approved)");

            // Milestone 3: No votes (auto-approved after timeout)
            console.log("\nðŸ“‹ Milestone 3: Creating...");
            await campaign.connect(campaignOwner).createNewMilestone("QmM3");
            await time.increase(15 * 24 * 60 * 60);
            await campaign.connect(campaignOwner).withdrawMilestone();
            console.log("  âœ“ Withdrawn ~2.23 ETH (no votes = auto-approved)");

            const finalBalance = await campaign.contractBalance();
            console.log("\nðŸš¨ FINAL RESULT:");
            console.log("  Contract balance:", ethers.formatEther(finalBalance), "ETH");
            console.log("  Owner extracted: ~10 ETH");
            console.log("  Community votes needed: ZERO for milestone 1, passive approval for 2&3");

            expect(finalBalance).to.be.lt(ethers.parseEther("0.01"));
        });
    });

    describe("ðŸŸ  MEDIUM: Unlimited Duration Extension", () => {
        it("Should demonstrate infinite campaign extension", async () => {
            const { factory, campaignOwner, donor1 } = await loadFixture(deployFixture);

            console.log("\n=== EXPLOIT: Infinite Campaign Extension ===");

            const campaign = await createCampaign(factory, campaignOwner, "10", 30);

            // Donor contributes
            await campaign.connect(donor1).giveDonationToCause({ value: ethers.parseEther("5") });
            console.log("\nðŸ’° Donor contributed: 5 ETH to 30-day campaign");

            let [, duration,] = await campaign.getFundingDetails();
            console.log("  Initial duration:", new Date(Number(duration) * 1000).toISOString());

            // Extension 1: Before expiry
            console.log("\nâ° Day 29: Owner extends by 1 year");
            await time.increase(29 * 24 * 60 * 60);
            await campaign.connect(campaignOwner).increaseCampaignPeriod(
                BigInt(Math.floor(Date.now() / 1000)) + BigInt(365 * 24 * 60 * 60)
            );

            [, duration,] = await campaign.getFundingDetails();
            console.log("  New duration:", new Date(Number(duration) * 1000).toISOString());
            const currentDuration1 = duration;

            // Extension 2: Again!
            console.log("\nâ° Day 394: Owner extends AGAIN by 1 year");
            await time.increase(365 * 24 * 60 * 60);
            const newEndTime2 = currentDuration1 + BigInt(365 * 24 * 60 * 60);
            await campaign.connect(campaignOwner).increaseCampaignPeriod(newEndTime2);

            [, duration,] = await campaign.getFundingDetails();
            console.log("  New duration:", new Date(Number(duration) * 1000).toISOString());

            console.log("\nðŸš¨ EXPLOIT SUCCESSFUL:");
            console.log("  âœ“ Campaign extended 2 times");
            console.log("  âœ“ Donor's 5 ETH locked for 2+ years instead of 30 days");
            console.log("  âœ“ Can be extended indefinitely");

            // Check if campaign is still running
            const campaignEnded = await campaign.campaignEnded();
            console.log("  Campaign ended:", campaignEnded);

            if (!campaignEnded) {
                console.log("\nðŸ’¡ NOTE: Donor CAN withdraw with 10% penalty even during active campaign");
                console.log("  This is intentional - donors have exit mechanism");
                console.log("  Owner can extend indefinitely but doesn't trap funds completely");
            }
        });
    });

    describe("ðŸŸ  MEDIUM: Minimum Funding Bypass", () => {
        it("Should demonstrate campaign with minimal funding", async () => {
            const { factory, campaignOwner, donor1 } = await loadFixture(deployFixture);

            console.log("\n=== EXPLOIT: Minimum Funding Bypass ===");

            // Create campaign with minimum possible goal
            console.log("\nðŸ“ Phase 1: Create campaign with 0.01 ETH goal");
            const campaign = await createCampaign(factory, campaignOwner, "0.01", 30);

            // Donor gives minimum
            console.log("\nðŸ’° Phase 2: Single donor gives 0.01 ETH");
            await campaign.connect(donor1).giveDonationToCause({ value: ethers.parseEther("0.01") });

            // End and withdraw
            await time.increase(31 * 24 * 60 * 60);
            await campaign.endCampaign();

            console.log("\nðŸ“‹ Phase 3: Create milestone and withdraw");
            await campaign.connect(campaignOwner).createNewMilestone("QmMinimal");

            const ownerBalBefore = await ethers.provider.getBalance(campaignOwner.address);
            await campaign.connect(campaignOwner).withdrawMilestone();
            const ownerBalAfter = await ethers.provider.getBalance(campaignOwner.address);

            const withdrawn = ownerBalAfter - ownerBalBefore;
            console.log("  Owner withdrew:", ethers.formatEther(withdrawn), "ETH");

            console.log("\nðŸš¨ EXPLOIT RESULT:");
            console.log("  âœ“ Campaign accepted with tiny goal (0.01 ETH)");
            console.log("  âœ“ Owner can withdraw despite insignificant funding");
            console.log("  âœ“ No minimum funding % required");
            console.log("  âœ“ Platform can be spammed with useless campaigns");
        });
    });

    describe("ðŸ“Š Exploit Impact Summary", () => {
        it("Should summarize all exploits", async () => {
            console.log("\n" + "=".repeat(60));
            console.log("                SECURITY EXPLOIT SUMMARY");
            console.log("=".repeat(60));

            console.log("\nðŸ”´ HIGH SEVERITY EXPLOITS:");
            console.log("  1. Donation Scale Manipulation");
            console.log("     - Attacker can gain 99%+ voting power with <10% investment");
            console.log("     - Complete governance takeover possible");
            console.log("     - Economic exploitation of early donors");

            console.log("\n  2. First Milestone Auto-Approval");
            console.log("     - Owner withdraws 33% without any community vote");
            console.log("     - Defeats purpose of milestone-based funding");
            console.log("     - Zero accountability for first withdrawal");

            console.log("\nðŸŸ  MEDIUM SEVERITY EXPLOITS:");
            console.log("  3. Unlimited Duration Extension");
            console.log("     - Funds can be locked indefinitely");
            console.log("     - Donors cannot withdraw from running campaigns");
            console.log("     - Breaks time-limited campaign promise");

            console.log("\n  4. Minimum Funding Bypass");
            console.log("     - 0.01 ETH campaigns allowed");
            console.log("     - No quality control");
            console.log("     - Platform spam possible");

            console.log("\n" + "=".repeat(60));
            console.log("RECOMMENDATION: Fix HIGH severity issues before production");
            console.log("=".repeat(60) + "\n");
        });
    });
});
